#!/usr/bin/env ruby

# frozen_string_literal: true

require 'date'
require 'json'
require 'logger'

logger = Logger.new(STDOUT)
logger.level = Logger::INFO
logger.formatter = proc do |severity, _datetime, _progname, msg|
  "#{severity}: #{msg}\n"
end

def pretty_number(number)
  number.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\\1,').reverse
end

begin
  require 'org-ruby'
rescue LoadError
  logger.error('could not load "org-ruby", is it installed?')
  exit 1
end

blog_path = "#{Dir.home}/src/blog"
if File.directory?(blog_path)
  logger.info("fetching git remotes for #{blog_path}")
  system("git -C #{blog_path} fetch --all --prune > /dev/null")
  logger.info("rebasing #{blog_path}")
  system("git -C #{blog_path} rebase origin/master")
else
  logger.error("git repo #{blog_path} not found!")
  exit 1
end

journal_path = if File.file?("#{Dir.home}/docs/journal.org")
                 "#{Dir.home}/docs/journal.org"
               elsif File.file?("#{Dir.home}/Documents/journal.org")
                 "#{Dir.home}/Documents/journal.org"
               else
                 logger.error('could not find journal file!')
                 exit 1
               end

logger.info "loading journal from #{journal_path}"
journal = Orgmode::Parser.load(journal_path)

logger.info "extracted #{journal.headlines.length} headlines from journal file"
headlines = journal.headlines.select { |h| h.level == 3 }
logger.info "filtered headlines to #{headlines.length} entry headlines"
headlines = headlines.reject { |h| h.tags.include? 'private' }
logger.info "filtered headlines to #{headlines.length} public entry headlines"

if headlines.empty?
  logger.error('no headlines left to parse, nothing to do!')
  exit 1
end

entries = headlines.map do |headline|
  logger.debug("parsing entry: #{headline.output_text}")
  date = Date.strptime(headline.output_text, '%Y-%m-%d %A')
  body_text = headline.body_lines.drop(1).collect(&:output_text).join(' ')
  {
    title: date.strftime('%A, %B %-e %Y'),
    filename: "#{date.strftime('%Y-%m-%d')}-entry.html",
    body_txt: body_text,
    body_html: Orgmode::Parser.new(body_text).to_html,
    tags: headline.tags
  }
end

output_path = "#{blog_path}/_posts/"
if File.directory?(output_path)
  logger.info("writing #{entries.length} to #{output_path}")
else
  logger.error("output directory #{output_path} not found!")
  exit 1
end

class StatsTracker
  def initialize(entries)
    @entries = entries
  end

  def to_json
    JSON.pretty_generate(
      average_word_count: pretty_number(average_word_count),
      top_three_tags: top_three_tags.map do |k, v|
        "#{k} (#{pretty_number(v)})"
      end,
      total_entries: pretty_number(@entries.length),
      total_word_count: pretty_number(total_word_count)
    )
  end

  private

  def average_word_count
    calc = word_count_list.inject { |sum, el| sum + el }.to_f / word_count_list.size
    calc.round
  end

  def total_word_count
    word_count_list.inject(0) { |sum, x| sum + x }
  end

  def word_count_list
    @entries.collect { |entry| entry[:body_txt].split.size }
  end

  def top_three_tags
    counts = Hash.new(0)
    @entries.each do |entry|
      entry[:tags].each do |v|
        counts[v] += 1
      end
    end
    counts.sort_by { |_k, v| v }.reverse.take(3)
  end
end

entries.each do |entry|
  target = File.join(output_path, entry[:filename])
  content = <<~CONTENT
    ---
    title: #{entry[:title]}
    tags: [#{entry[:tags].join(',')}]
    ---
    #{entry[:body_html]}
  CONTENT
  logger.debug("writing #{target}")
  File.open(target, 'w+') { |file| file.write(content) }
end

stats_target = File.join(blog_path, '_data/stats.json')
logger.info("writing stats to #{stats_target}")
File.open(stats_target, 'w+') do |f|
  f.write(StatsTracker.new(entries).to_json)
end

logger.info('writing commit')
system(
  [
    "git -C #{blog_path} add -A > /dev/null && ",
    "git -C #{blog_path} commit -m \"publish: #{Time.now.getutc}\" > /dev/null &&",
    "git -C #{blog_path} push origin master:master > /dev/null ||",
    "echo 'nothing to do' > /dev/null"
  ].join(' ')
)

logger.info('done!')
